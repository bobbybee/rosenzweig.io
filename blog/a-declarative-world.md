A Declarative World
=================
_10 Feb 2017_

My favourite programming language is markdown -- this post is written in it, in fact! For plain text, it is what-you-see-is-what-you-get (WYSIWYG), and for formatted-text, \*\***it**\*\* is \**natural*\*. It isn't without its faults, of course; the image syntax is understandably incomprehensible. But at the end of the day, it does what it claims to do, and it does it well.

Another language (or notation) I like a great deal is the language of mathematics. Again, it is not without faults; I maintain whoever chose^[OK, I know, I know, language and notation are evolved, not chosen..] the notation for formal logic and set theory had a vendetta against students. But for the most part, it is clean, mostly unambiguous, and usually legible. There are still, of course, movements trying to change the notation, like a personal favourite of mine, [Tau-ism](http://tauday.com/), and I concede that the meaning is rarely obvious when first learning the notation. Indeed, [Bret Victor](http://worrydream.com/KillMath/) quipped that mathematics "should not be restricted to those with a freakish knack for manipulating abstract symbols". He might be right, although that issue is largely tangential here. (Get it? _Tangential_). Nevertheless, for what it does mathematical notation is nice.

Another paradigm with which most people are familiar is flow charts. They are visual representations of the control flow of a constrained program. If you want to sound smart at MIT parties, the fancy computer science term for this is a finite-state machine (FSM). Computationally, they are rather powerful, and for many people, they are intuitive.

So, many of you might interrupt me now, pointing out, "Alyssa, none of these are programming languages!" Indeed, these 'languages' are non-Turing-complete, non-programming, non-general, and at this point you might interject, "non-useful". In a sense, these languages are closer to data, capable of being interpreted by a human or a machine. I feel this is a deeper idea than the von Neumann equivalency between code and data, since I'm not arguing that this is code. In any event, however constrained these "languages" may be, they might just be what a person wants.

Too often, in our "ooo, shiny" culture, we settle for more. But from my perspective, mathematicians want maths notation, not [numpy](http://www.numpy.org/). Writers want markdown, not [HTML, CSS, and JavaScript](javascript-vanity.html). I'm not really sure there are people who want flow charts, but hey! Point is, enjoying programming is fine as a pastime, but it should not be the prerequisite for  a user to control their computer. Luckily, as I said, most of the time programming is not necessary, only data.

I have a vision for a more declarative (digital) world. Websites should be written in markdown, not HTML, CSS, and JavaScript. Scientific algorithms should be published as a [specification](magic-specifications.html), not messy programs in a mess of high-level programming languages and complex supporting libraries. And most of all, end-users should have the flexibility to participate in the development of the software they use, something that currently has a massive barrier to entry. Death to C, death to Lisp, and most of all death to JavaScript. We can build a more declarative world.
