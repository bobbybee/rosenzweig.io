Linux on the Pi: Post Mortem
==================
_13 Feb 2017_

Over winter break, I successfully modified Kristina Brook's free Raspberry Pi [firmware](https://github.com/christinaa/rpi-open-firmware) to bring-up a Linux kernel. This was, of course, the original aim for the project to begin with, and most of the bits and pieces were already there from when the firmware was actively developed in June of 2016. That being said, it was purely a proof-of-concept showing ARM initialization -- no payloads were actually loaded, let alone the Linux kernel. In this post, we'll walk through the steps of writing the neccessary bootloader (and all the pitfalls to which were victims.)

First things first, what exactly is that we're trying to accomplish? Well, we need to know a bit about how computers boot. Essentially it's a chain of programs, each larger than the next whose job is to load the next one. Over years of legacy code piling up, it is admittedly rather convoluted, especially on x86. But the theory is the same: the bootrom (burned into the chip) loads the firmware, the firmware loads the bootloader, the bootloader loads the kernel, the kernel loads the userspace. The exact contents of each step vary wildly -- and before you ask, yes, this is why you're computer takes so long in the morning :-)

The Raspberry Pi is somewhat... special in this regard. Usually, for systems with a graphics processor (like my Intel laptop), the CPU boots up and loads the GPU sometime later. For various (strange) historical reasons, the Raspberry Pi instead boots from the VideoCore 4 GPU, which loads the CPU at-will. Another caveat is that the firmware is not actually on a ROM like you would expect -- it's on an SD card, or potentially even stranger mediums. Finally, while third-party bootloaders like U-Boot exist for the Pi, the stock firmware is setup to boot the Linux kernel directly. So, the boot chain for the official firmware is something like: bootrom (VC4) loads the GPU operating system, the GPU loads the kernel into memory, the GPU loads ARM with a stub program, the ARM stub jumps to the Linux kernel, and the Linux kernel loads user-space. It's pretty crazy.

Some of these.. peculiarities are due to fundamental differences in the system-on-chip used in the Raspberry Pi. Much of it was simply design of the firmware. Kristina's firmware used a slightly different path, from which we'll work: the bootrom loads her minimal GPU program, the GPU brings up ARM with an embedded ARM program, the ARM program initializes a handful of additional peripherals and then hangs. What peripherals, you may ask? Well, most notably she was kind enough to include an eMMC driver (for SD cards) and she bundled a library for reading FAT filesystems. That is, the infrastructure is setup to read files from the SD card.

The (simplest) path from here is clear. Rather than hang at the end of ARM program, load the kernel from the SD card and chuck it somewhere into memory. Then, in theory, you should be able to jump to it on ARM, and let Torvalds' crowd do the rest. It's easy... right?

Unfortunately, Linux is rather.. demanding, hence why bootloaders are used at all. If you're curious at the exact details on ARM -- which are comparatively trivial next to certain other architectures, ahem -- see the [official documentation](https://github.com/anholt/linux/blob/rpi-4.4.y/Documentation/arm/Booting). See, before we can just jump to the kernel image in memory, it's necessary to pass a variety of arguments to it. There are the easy ones, like setting a few registers to magic values, but something stands out as particularly irritating: the legacy "tagged list" or the more modern device tree. To understand the purpose -- and associated nightmares -- of these, it's necessary to take another detour into the typical boot process.

Essentially, the kernel has two jobs: managing resources for users via scheduling, permission systems, and the like (interesting to other people), and managing the hardware (interesting to us). The former category is easy, and it's fairly similar across architecture -- when people say a kernel is "a UNIX system", they are generally referring to this component. The latter, however, is necessarily different for each and every hardware configuration. Actually implementing these drivers is a nightmare we'll approach later; for now, it's just necessary to know it's there, and to ask the inevitable question: precisely *what* hardware does the kernel manage?

It turns out there are a few obvious ways of handling this. The kernel could guess (bad idea). It could hard code what hardware is available (simple but unmaintainable). It could probe the system at run-time (sounds nice but is inevitably difficult in practice). Certain architectures, of course, favour certain methods. x86, for one, favours probing, encouraged by (highly criticized) systems like ACPI, EFI, and the BIOS. On the other hand, ARM, used in the Raspberry Pi and focused on embedded systems, assumes the kernel automagically knows what hardware to use, by hardcoding I suppose. Linux on ARM takes a middle ground: it uses a configurable device tree that contains a variety of information about the hardware, loaded at runtime. Normally I'd write this off as something for the geeks on the mailing list to sort out, but apparently information "loaded at runtime" is our responsibility now.

